{"version":3,"file":"react-if.cjs.production.min.js","sources":["../src/render.tsx","../src/Case.tsx","../src/Default.tsx","../src/Else.tsx","../src/Fallback.tsx","../src/getConditionResults.ts","../src/isThenable.ts","../src/utils.ts","../src/Then.tsx","../src/IfAsync.tsx","../src/hooks.ts","../src/If.tsx","../src/Switch.tsx","../src/Unless.tsx","../src/When.tsx"],"sourcesContent":["import React, { Fragment } from 'react';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nexport const render: FCWithImplicitChildren = (props) => {\n  if (typeof props.children === 'function') {\n    return <Fragment>{props.children()}</Fragment>;\n  }\n\n  return <Fragment>{props.children || null}</Fragment>;\n};\n","import type { FC } from 'react';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nexport const Case: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nexport const Default: FCWithImplicitChildren = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nexport const Else: FCWithImplicitChildren = (props) => render(props);\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nexport const Fallback: FCWithImplicitChildren = (props) => render(props);\n","import type { BooleanLike } from './types';\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nexport const getConditionResult = (condition: BooleanLike | ((...args: unknown[]) => BooleanLike)): boolean => {\n  const conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n\n  return conditionResult;\n};\n","/**\n * The MIT License (MIT)\n *\n * Copyright Â© `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\ninterface Thenable {\n  then: Function;\n  catch: Function;\n}\n\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n\nexport function isFunction(input: unknown): input is Function {\n  return typeof input === 'function';\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n  return Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n","import { isThenable } from './isThenable';\nimport type { CancellablePromise, ExtendablePromise } from './types';\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nexport const shallowArraysEqual = (a: any[], b: any[]): boolean => {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nexport const createCancellablePromise = <T>(promise: ExtendablePromise<T>): CancellablePromise => {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n\n  const isCancelled = { value: false };\n\n  const wrappedPromise: ExtendablePromise<T> = new Promise(async (res, rej) => {\n    try {\n      const d = await promise;\n      return !isCancelled.value && res(d);\n    } catch (error) {\n      !isCancelled.value && rej(error);\n    }\n  });\n\n  // Forward potential additional properties\n  Object.keys(promise).forEach((key) => {\n    wrappedPromise[key] = promise[key];\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCancelled.value = true;\n    }\n  };\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nexport const Then: FCWithImplicitChildren = (props) => render(props);\n","import React, { Fragment, useEffect, useMemo, useRef, useState, PropsWithChildren, ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { useSingleton } from './hooks';\nimport { isThenable } from './isThenable';\nimport { Then } from './Then';\nimport type { AsyncSupportProps, CancellablePromise, ExtendablePromise } from './types';\nimport { createCancellablePromise } from './utils';\n\n/**\n * Props for IfAsync\n */\ninterface Props<T> extends AsyncSupportProps, PropsWithChildren<{ promise: ExtendablePromise<T> }> {}\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\n\nexport function IfAsync<T = any>({ promise, keepAlive = false, children }: Props<T>) {\n  const [isResolved, setIsResolved] = useState<null | boolean>(null);\n  const [returnValue, setReturnValue] = useState(null);\n\n  // Make promise cancellable\n  const cancellablePromise = useMemo((): CancellablePromise => createCancellablePromise(promise), [promise]);\n  const history = useRef<CancellablePromise[]>([]); // Keep history of promises\n\n  // Handle unmount\n  useEffect(() => {\n    return () => {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n\n  // Await promise\n  useSingleton(async () => {\n    setIsResolved(null);\n    setReturnValue(null);\n\n    try {\n      const data = await cancellablePromise.promise;\n      setReturnValue(data);\n      setIsResolved(true);\n      history.current.push(cancellablePromise);\n    } catch (error) {\n      setReturnValue(error as any);\n      setIsResolved(false);\n      history.current.push(cancellablePromise);\n    }\n  }, [cancellablePromise.promise]);\n\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n\n  if (isResolved === null) {\n    // Promise is pending\n    const hasFallback = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Fallback);\n    return <Fragment>{hasFallback || null}</Fragment>;\n  }\n\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    const hasElse = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Else);\n    if (!hasElse) return <Fragment>{null}</Fragment>;\n\n    // Inject caught error\n    let elseElement = hasElse;\n    if (typeof hasElse.props.children === 'function') {\n      elseElement = {\n        ...hasElse,\n        props: {\n          ...hasElse.props,\n          children: () => hasElse.props.children(returnValue, history.current, cancellablePromise.promise)\n        }\n      };\n    }\n    return <Fragment>{elseElement}</Fragment>;\n  }\n\n  // Promise is fulfilled and resolved\n  const hasThen = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Then);\n  if (!hasThen) return <Fragment>{null}</Fragment>;\n\n  // Inject promise return value\n  let thenElement = hasThen;\n\n  if (typeof hasThen.props.children === 'function') {\n    thenElement = {\n      ...hasThen,\n      props: {\n        ...hasThen.props,\n        children: () => hasThen.props.children(returnValue, history.current, cancellablePromise.promise)\n      }\n    };\n  }\n\n  return <Fragment>{thenElement}</Fragment>;\n}\n","import { useRef } from 'react';\nimport { shallowArraysEqual } from './utils';\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nexport const useSingleton = (callback: () => any, dependencies: any[] = []) => {\n  const hasRan = useRef<boolean>(false);\n  const lastDependencies = useRef<any[]>([]);\n\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(`Incorrect callback parameter for useSingleton hook; expected a function, but got: '${typeof callback}'.`);\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(`Incorrect dependencies parameter for useSingleton; expected an array, but got: '${typeof dependencies}'.`);\n  }\n\n  const hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    const hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n\n  callback();\n  hasRan.current = true;\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { getConditionResult } from './getConditionResults';\nimport { IfAsync } from './IfAsync';\nimport { isThenable } from './isThenable';\nimport { Then } from './Then';\nimport { tinyWarning } from './tinyWarning';\nimport type { ComponentWithConditionPropsAsyncSupport, ExtendablePromise } from './types';\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const If: FC<ComponentWithConditionPropsAsyncSupport> = ({ condition, keepAlive = false, children }) => {\n  if (!children) {\n    return null;\n  }\n\n  tinyWarning(\n    (!Array.isArray(children) && !((children as ReactElement).type === Else || (children as ReactElement).type === Then)) ||\n      !(React.Children.toArray(children) as ReactElement[]).every((child) => child.type === Else || child.type === Then || child.type === Fallback),\n    'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children'\n  );\n\n  if (isThenable(condition)) {\n    return (\n      <IfAsync promise={condition as ExtendablePromise<any>} keepAlive={keepAlive}>\n        {children}\n      </IfAsync>\n    );\n  }\n\n  const conditionResult = getConditionResult(condition);\n\n  return <Fragment>{(React.Children.toArray(children) as ReactElement[]).find((c) => (c.type !== Else) !== !conditionResult) || null}</Fragment>;\n};\n","import React, { ReactElement } from 'react';\nimport { Case } from './Case';\nimport { Default } from './Default';\nimport { getConditionResult } from './getConditionResults';\nimport { isFunction } from './isThenable';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nexport const Switch: FCWithImplicitChildren = ({ children }) => {\n  // -- Inspired by react-router --\n\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  let matchingCase: ReactElement | undefined = undefined;\n  let defaultCase: ReactElement | undefined = undefined;\n\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n\n  React.Children.forEach(children, (child) => {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (!matchingCase && child.type === Case) {\n      const { condition } = child.props;\n\n      const conditionResult = getConditionResult(condition);\n\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n\n  return matchingCase ?? defaultCase ?? null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const Unless: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return !conditionResult && children ? render({ children }) : null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const When: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return conditionResult && children ? render({ children }) : null;\n};\n"],"names":["render","props","React","createElement","Fragment","children","Case","_ref","_ref$children","Default","Else","Fallback","getConditionResult","condition","Boolean","isFunction","input","isThenable","Promise","prototype","Reflect","has","then","hasThen","hasCatch","Then","IfAsync","promise","_ref$keepAlive","keepAlive","_useState","useState","isResolved","setIsResolved","_useState2","returnValue","setReturnValue","cancellablePromise","useMemo","Error","isCancelled","value","wrappedPromise","_asyncToGenerator","_regeneratorRuntime","mark","_callee","res","rej","d","wrap","_context","prev","next","sent","abrupt","t0","stop","_x","_x2","apply","this","arguments","Object","keys","forEach","key","cancel","createCancellablePromise","history","useRef","useEffect","callback","dependencies","hasRan","lastDependencies","Array","isArray","length","a","b","i","shallowArraysEqual","current","useSingleton","push","hasFallback","Children","toArray","find","c","type","hasElse","elseElement","_extends","thenElement","every","child","conditionResult","_ref2","_matchingCase","matchingCase","undefined","defaultCase","isValidElement"],"mappings":"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"}