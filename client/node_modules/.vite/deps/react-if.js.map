{
  "version": 3,
  "sources": ["../../react-if/src/render.tsx", "../../react-if/src/Case.tsx", "../../react-if/src/Default.tsx", "../../react-if/src/Else.tsx", "../../react-if/src/Fallback.tsx", "../../react-if/src/getConditionResults.ts", "../../react-if/src/isThenable.ts", "../../react-if/src/utils.ts", "../../react-if/src/hooks.ts", "../../react-if/src/Then.tsx", "../../react-if/src/IfAsync.tsx", "../../react-if/src/tinyWarning.ts", "../../react-if/src/If.tsx", "../../react-if/src/Switch.tsx", "../../react-if/src/Unless.tsx", "../../react-if/src/When.tsx"],
  "sourcesContent": ["import React, { Fragment } from 'react';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nexport const render: FCWithImplicitChildren = (props) => {\n  if (typeof props.children === 'function') {\n    return <Fragment>{props.children()}</Fragment>;\n  }\n\n  return <Fragment>{props.children || null}</Fragment>;\n};\n", "import type { FC } from 'react';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nexport const Case: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ children = null }) => {\n  return render({ children });\n};\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nexport const Default: FCWithImplicitChildren = ({ children = null }) => {\n  return render({ children });\n};\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nexport const Else: FCWithImplicitChildren = (props) => render(props);\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nexport const Fallback: FCWithImplicitChildren = (props) => render(props);\n", "import type { BooleanLike } from './types';\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nexport const getConditionResult = (condition: BooleanLike | ((...args: unknown[]) => BooleanLike)): boolean => {\n  const conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n\n  return conditionResult;\n};\n", "/**\n * The MIT License (MIT)\n *\n * Copyright Â© `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\ninterface Thenable {\n  then: Function;\n  catch: Function;\n}\n\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n\nexport function isFunction(input: unknown): input is Function {\n  return typeof input === 'function';\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n  return Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n", "import { isThenable } from './isThenable';\nimport type { CancellablePromise, ExtendablePromise } from './types';\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nexport const shallowArraysEqual = (a: any[], b: any[]): boolean => {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nexport const createCancellablePromise = <T>(promise: ExtendablePromise<T>): CancellablePromise => {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n\n  const isCancelled = { value: false };\n\n  const wrappedPromise: ExtendablePromise<T> = new Promise(async (res, rej) => {\n    try {\n      const d = await promise;\n      return !isCancelled.value && res(d);\n    } catch (error) {\n      !isCancelled.value && rej(error);\n    }\n  });\n\n  // Forward potential additional properties\n  Object.keys(promise).forEach((key) => {\n    wrappedPromise[key] = promise[key];\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCancelled.value = true;\n    }\n  };\n};\n", "import { useRef } from 'react';\nimport { shallowArraysEqual } from './utils';\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nexport const useSingleton = (callback: () => any, dependencies: any[] = []) => {\n  const hasRan = useRef<boolean>(false);\n  const lastDependencies = useRef<any[]>([]);\n\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(`Incorrect callback parameter for useSingleton hook; expected a function, but got: '${typeof callback}'.`);\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(`Incorrect dependencies parameter for useSingleton; expected an array, but got: '${typeof dependencies}'.`);\n  }\n\n  const hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    const hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n\n  callback();\n  hasRan.current = true;\n};\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nexport const Then: FCWithImplicitChildren = (props) => render(props);\n", "import React, { Fragment, useEffect, useMemo, useRef, useState, PropsWithChildren, ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { useSingleton } from './hooks';\nimport { isThenable } from './isThenable';\nimport { Then } from './Then';\nimport type { AsyncSupportProps, CancellablePromise, ExtendablePromise } from './types';\nimport { createCancellablePromise } from './utils';\n\n/**\n * Props for IfAsync\n */\ninterface Props<T> extends AsyncSupportProps, PropsWithChildren<{ promise: ExtendablePromise<T> }> {}\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\n\nexport function IfAsync<T = any>({ promise, keepAlive = false, children }: Props<T>) {\n  const [isResolved, setIsResolved] = useState<null | boolean>(null);\n  const [returnValue, setReturnValue] = useState(null);\n\n  // Make promise cancellable\n  const cancellablePromise = useMemo((): CancellablePromise => createCancellablePromise(promise), [promise]);\n  const history = useRef<CancellablePromise[]>([]); // Keep history of promises\n\n  // Handle unmount\n  useEffect(() => {\n    return () => {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n\n  // Await promise\n  useSingleton(async () => {\n    setIsResolved(null);\n    setReturnValue(null);\n\n    try {\n      const data = await cancellablePromise.promise;\n      setReturnValue(data);\n      setIsResolved(true);\n      history.current.push(cancellablePromise);\n    } catch (error) {\n      setReturnValue(error as any);\n      setIsResolved(false);\n      history.current.push(cancellablePromise);\n    }\n  }, [cancellablePromise.promise]);\n\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n\n  if (isResolved === null) {\n    // Promise is pending\n    const hasFallback = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Fallback);\n    return <Fragment>{hasFallback || null}</Fragment>;\n  }\n\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    const hasElse = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Else);\n    if (!hasElse) return <Fragment>{null}</Fragment>;\n\n    // Inject caught error\n    let elseElement = hasElse;\n    if (typeof hasElse.props.children === 'function') {\n      elseElement = {\n        ...hasElse,\n        props: {\n          ...hasElse.props,\n          children: () => hasElse.props.children(returnValue, history.current, cancellablePromise.promise)\n        }\n      };\n    }\n    return <Fragment>{elseElement}</Fragment>;\n  }\n\n  // Promise is fulfilled and resolved\n  const hasThen = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Then);\n  if (!hasThen) return <Fragment>{null}</Fragment>;\n\n  // Inject promise return value\n  let thenElement = hasThen;\n\n  if (typeof hasThen.props.children === 'function') {\n    thenElement = {\n      ...hasThen,\n      props: {\n        ...hasThen.props,\n        children: () => hasThen.props.children(returnValue, history.current, cancellablePromise.promise)\n      }\n    };\n  }\n\n  return <Fragment>{thenElement}</Fragment>;\n}\n", "/**\n * Handles errors by throwing them to the console.\n * `__DEV__` is replaced by dts-cli using {@link https://www.npmjs.com/package/babel-plugin-dev-expression babel-plugin-dev-expressions}\n * which will ensure this entire throw is not present in production\n * @param condition The condition to check\n * @param message The message to throw if `condition` resolves to `true`\n */\nexport function tinyWarning(condition: boolean, message: string): asserts condition {\n  if (__DEV__) {\n    if (condition) {\n      // check console for IE9 support which provides console\n      // only with open devtools\n\n      if (typeof console !== 'undefined') {\n        console.warn(message);\n      }\n\n      // Throwing an error and catching it immediately to improve debugging\n      // Users can utilize 'pause on caught exceptions' to get into this throw\n      try {\n        throw new Error(message);\n      } catch (x) {\n        // noop\n      }\n    }\n  }\n}\n\ndeclare global {\n  let __DEV__: boolean;\n}\n", "import React, { FC, Fragment, ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { getConditionResult } from './getConditionResults';\nimport { IfAsync } from './IfAsync';\nimport { isThenable } from './isThenable';\nimport { Then } from './Then';\nimport { tinyWarning } from './tinyWarning';\nimport type { ComponentWithConditionPropsAsyncSupport, ExtendablePromise } from './types';\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const If: FC<ComponentWithConditionPropsAsyncSupport> = ({ condition, keepAlive = false, children }) => {\n  if (!children) {\n    return null;\n  }\n\n  tinyWarning(\n    (!Array.isArray(children) && !((children as ReactElement).type === Else || (children as ReactElement).type === Then)) ||\n      !(React.Children.toArray(children) as ReactElement[]).every((child) => child.type === Else || child.type === Then || child.type === Fallback),\n    'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children'\n  );\n\n  if (isThenable(condition)) {\n    return (\n      <IfAsync promise={condition as ExtendablePromise<any>} keepAlive={keepAlive}>\n        {children}\n      </IfAsync>\n    );\n  }\n\n  const conditionResult = getConditionResult(condition);\n\n  return <Fragment>{(React.Children.toArray(children) as ReactElement[]).find((c) => (c.type !== Else) !== !conditionResult) || null}</Fragment>;\n};\n", "import React, { ReactElement } from 'react';\nimport { Case } from './Case';\nimport { Default } from './Default';\nimport { getConditionResult } from './getConditionResults';\nimport { isFunction } from './isThenable';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nexport const Switch: FCWithImplicitChildren = ({ children }) => {\n  // -- Inspired by react-router --\n\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  let matchingCase: ReactElement | undefined = undefined;\n  let defaultCase: ReactElement | undefined = undefined;\n\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n\n  React.Children.forEach(children, (child) => {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (!matchingCase && child.type === Case) {\n      const { condition } = child.props;\n\n      const conditionResult = getConditionResult(condition);\n\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n\n  return matchingCase ?? defaultCase ?? null;\n};\n", "import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const Unless: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return !conditionResult && children ? render({ children }) : null;\n};\n", "import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const When: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return conditionResult && children ? render({ children }) : null;\n};\n"],
  "mappings": "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",
  "names": ["render", "props", "children", "React", "createElement", "Fragment", "Case", "_ref", "_ref$children", "Default", "Else", "Fallback", "getConditionResult", "condition", "conditionResult", "Boolean", "isFunction", "input", "hasThen", "Reflect", "has", "then", "hasCatch", "isThenable", "Promise", "prototype", "shallowArraysEqual", "a", "b", "Array", "isArray", "Error", "length", "i", "createCancellablePromise", "promise", "isCancelled", "value", "wrappedPromise", "_asyncToGenerator", "_regeneratorRuntime", "mark", "_callee", "res", "rej", "d", "wrap", "_callee$", "_context", "prev", "next", "sent", "abrupt", "t0", "stop", "_x", "_x2", "apply", "arguments", "Object", "keys", "forEach", "key", "cancel", "useSingleton", "callback", "dependencies", "hasRan", "useRef", "lastDependencies", "hasDependencies", "hasAnyDependencyChanged", "current", "Then", "IfAsync", "_ref$keepAlive", "keepAlive", "_useState", "useState", "isResolved", "setIsResolved", "_useState2", "returnValue", "setReturnValue", "cancellablePromise", "useMemo", "history", "useEffect", "data", "push", "hasFallback", "Children", "toArray", "find", "c", "type", "hasElse", "elseElement", "_extends", "thenElement", "tinyWarning", "message", "process", "console", "warn", "x", "If", "every", "child", "Switch", "_ref2", "_matchingCase", "matchingCase", "undefined", "defaultCase", "isValidElement", "Unless", "When"]
}
